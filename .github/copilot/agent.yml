# GitHub Copilot Agent Configuration for AutoGPT Platform
# This configuration maximizes Copilot's capabilities for AutoGPT platform development
# Reference: https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/customize-the-agent-environment

# Agent behavior configuration
agent:
  name: "AutoGPT Platform Assistant"
  description: "AI-powered coding assistant optimized for AutoGPT platform development with deep domain knowledge"
  
# Context and project understanding
context:
  project_type: "ai_platform_monorepo"
  description: |
    AutoGPT Platform is a sophisticated AI agent platform monorepo containing:
    - **Backend** (/autogpt_platform/backend): Python FastAPI server with async support
    - **Frontend** (/autogpt_platform/frontend): Next.js React application with TypeScript
    - **Shared Libraries** (/autogpt_platform/autogpt_libs): Common Python utilities
    - **Documentation** (/docs): Platform documentation and guides
    
    Technology Stack:
    - Backend: Python 3.10+, FastAPI, Prisma ORM, PostgreSQL with pgvector
    - Frontend: Next.js 14+, TypeScript, TailwindCSS, React Query, Radix UI
    - Infrastructure: Docker, RabbitMQ, Redis, ClamAV, Google Cloud Storage
    - Authentication: JWT-based with Supabase integration
    - AI Integration: Multiple LLM providers (OpenAI, Anthropic, Groq, etc.)
  
  key_concepts:
    - "Agent Graphs": Workflow definitions stored as JSON, executed by the backend
    - "Blocks": Reusable components in /backend/blocks/ that perform specific tasks
    - "Integrations": OAuth and API connections stored per user
    - "Store": Marketplace for sharing agent templates
    - "Executors": Separate executor service that processes agent workflows
    - "Virus Scanning": ClamAV integration for file upload security
    - "Cache Protection": Security middleware preventing sensitive data caching

# Essential development commands
essential_commands:
  backend:
    setup:
      - "cd autogpt_platform/backend && poetry install"
      - "poetry run prisma migrate dev"
      - "docker compose up -d"
    development:
      - "poetry run serve"  # Start backend server
      - "poetry run test"   # Run all tests
      - "poetry run pytest path/to/test_file.py::test_function_name"  # Run specific test
      - "poetry run pytest backend/blocks/test/test_block.py -xvs"  # Run block tests
      - "poetry run format"  # Black + isort formatting
      - "poetry run lint"    # ruff linting
    testing:
      - "poetry run pytest path/to/test.py --snapshot-update"  # Update snapshots
      - "poetry run pytest 'backend/blocks/test/test_block.py::test_available_blocks[BlockName]' -xvs"  # Test specific block
      
  frontend:
    setup:
      - "cd autogpt_platform/frontend && npm install"
    development:
      - "npm run dev"        # Start development server
      - "npm run build"      # Build production
      - "npm run test"       # Run E2E tests
      - "npm run storybook"  # Component development
      - "npm run types"      # Type checking

# Language-specific configurations
languages:
  python:
    version: "3.10+"
    framework: "fastapi"
    orm: "prisma"
    patterns:
      - "Use Pydantic v2 models for data validation and serialization"
      - "Follow async/await patterns for all I/O operations"
      - "Use dependency injection with FastAPI's Depends()"
      - "Implement proper error handling with custom exception classes"
      - "Use typing annotations extensively for better code clarity"
      - "Follow the repository pattern for database operations"
      - "Use Prisma for database operations with proper transaction handling"
      - "Use uuid.uuid4() for generating block UUIDs"
      - "Implement snapshot testing for API responses"
      - "Use pytest fixtures for common test setup"
    
    block_development:
      - "Inherit from Block base class in /backend/backend/blocks/"
      - "Define Input/Output schemas with Pydantic models"
      - "Implement run method with proper error handling"
      - "Register in block registry with unique UUID"
      - "Consider input/output compatibility for graph connections"
      - "Use descriptive field descriptions for UI generation"
    
    api_development:
      - "Routes go in /backend/backend/server/routers/"
      - "Add/update Pydantic models in same directory"
      - "Write tests alongside the route file"
      - "Use proper dependency injection for authentication"
      - "Implement proper error responses and status codes"
      - "Add to CACHEABLE_PATHS in security middleware if caching needed"
    
    database_patterns:
      - "Use Prisma schema in /backend/schema.prisma"
      - "Run 'poetry run prisma migrate dev' for schema changes"
      - "Use proper transaction handling for multi-step operations"
      - "Follow naming conventions: snake_case for fields"
      - "Consider pgvector for embedding operations"
    
    security_patterns:
      - "Never hardcode credentials, use environment variables"
      - "Validate all user inputs with Pydantic models"
      - "Use proper authentication with get_current_user dependency"
      - "Follow OWASP best practices for API security"
      - "Be aware of cache protection middleware behavior"
    
    conventions:
      - "File naming: snake_case for modules and files"
      - "Class naming: PascalCase for classes"
      - "Function naming: snake_case for functions and methods"
      - "Constants: UPPER_SNAKE_CASE"
      - "Private methods: prefix with single underscore"
      - "Import order: standard library, third-party, local imports"
      - "Test files: end with _test.py and colocated with source"
    
    testing:
      framework: "pytest"
      patterns:
        - "Use fixtures for common test setup"
        - "Test files end with _test.py"
        - "Use descriptive test names that explain the scenario"
        - "Mock external dependencies and API calls"
        - "Use snapshot testing for API responses"
        - "Run 'poetry run pytest --snapshot-update' when expected output changes"

  typescript:
    version: "5.0+"
    framework: "next.js"
    ui_library: "radix_ui"
    state_management: "react_query"
    patterns:
      - "Use React hooks and functional components"
      - "Implement proper TypeScript types for all props and state"
      - "Use React Query for server state management"
      - "Follow Next.js app router patterns"
      - "Use TailwindCSS for styling with consistent design system"
      - "Implement proper error boundaries and loading states"
      - "Use Zustand or React Context for client state management"
      - "Use Radix UI primitives for accessible components"
      - "Implement proper data-testid attributes for Playwright tests"
    
    component_development:
      - "Components go in /frontend/src/components/"
      - "Use existing UI components from /frontend/src/components/ui/"
      - "Add Storybook stories for new components"
      - "Test with Playwright if user-facing"
      - "Follow compound component patterns for complex UI"
      - "Use React.memo for performance optimization"
    
    workflow_builder:
      - "Use @xyflow/react for visual graph editor"
      - "Implement proper node and edge types"
      - "Handle graph state management with React Query"
      - "Use proper TypeScript types for node data"
      - "Implement drag and drop functionality"
    
    api_integration:
      - "Use React Query for data fetching and caching"
      - "Implement proper error handling with React Query"
      - "Use Supabase client for real-time updates"
      - "Handle authentication state with context"
      - "Implement proper loading and error states"
    
    performance:
      - "Use React.memo and useMemo for expensive computations"
      - "Implement proper code splitting with Next.js"
      - "Use proper image optimization with Next.js Image"
      - "Implement proper caching strategies"
    
    conventions:
      - "File naming: kebab-case for components and pages"
      - "Component naming: PascalCase for React components"
      - "Hook naming: camelCase starting with 'use'"
      - "Type naming: PascalCase with descriptive names"
      - "Interface naming: PascalCase starting with 'I' when needed"
      - "Enum naming: PascalCase with descriptive values"
      - "Use absolute imports from /frontend/src/"
    
    testing:
      framework: "playwright"
      patterns:
        - "E2E tests for critical user flows"
        - "Component testing for complex UI logic"
        - "Use proper data-testid attributes for reliable selectors"
        - "Test authentication flows and protected routes"
        - "Test workflow builder functionality"

# File patterns and preferences
files:
  # Primary development files
  focus_patterns:
    - "autogpt_platform/backend/**/*.py"
    - "autogpt_platform/frontend/**/*.{ts,tsx}"
    - "autogpt_platform/autogpt_libs/**/*.py"
    - "autogpt_platform/backend/backend/blocks/**/*.py"
    - "autogpt_platform/backend/backend/integrations/**/*.py"
    - "autogpt_platform/backend/backend/server/routers/**/*.py"
    - "autogpt_platform/frontend/src/**/*.{ts,tsx}"
    - "autogpt_platform/frontend/src/components/**/*.{ts,tsx}"
    - "autogpt_platform/backend/schema.prisma"
    - "docs/**/*.md"
    - "AGENTS.md"
    - "autogpt_platform/CLAUDE.md"

  # Files to exclude from suggestions
  exclude_patterns:
    - "**/__pycache__/**"
    - "**/node_modules/**"
    - "**/dist/**"
    - "**/build/**"
    - "**/.next/**"
    - "**/coverage/**"
    - "**/*.pyc"
    - "**/migrations/**"
    - "**/snapshots/**"
    - "**/.env*"
    - "**/pnpm-lock.yaml"
    - "**/poetry.lock"
    - "**/generated/**"
    - "**/.pytest_cache/**"
    - "**/storybook-static/**"

# Coding standards and best practices
standards:
  code_quality:
    - "Follow PEP 8 for Python code formatting"
    - "Use ESLint and Prettier for TypeScript/JavaScript formatting"
    - "Write comprehensive docstrings for public APIs"
    - "Include type hints for all function parameters and returns"
    - "Handle errors gracefully with proper exception handling"
    - "Use meaningful variable and function names"
    - "Keep functions focused and single-purpose"
    - "Write self-documenting code with clear logic flow"

  security:
    - "Never hardcode API keys or sensitive credentials"
    - "Use environment variables for configuration"
    - "Validate all user inputs and API parameters"
    - "Implement proper authentication and authorization"
    - "Follow OWASP security best practices"
    - "Use secure random generators for tokens and IDs"

  performance:
    - "Use async/await for I/O bound operations"
    - "Implement proper database connection pooling"
    - "Use caching strategies for expensive operations"
    - "Optimize database queries to avoid N+1 problems"
    - "Implement proper pagination for large datasets"
    - "Use React.memo and useMemo for expensive computations"

# Domain-specific guidance
domain_knowledge:
  architecture_overview:
    backend:
      - "API Layer: FastAPI with REST and WebSocket endpoints"
      - "Database: PostgreSQL with Prisma ORM, includes pgvector for embeddings"
      - "Queue System: RabbitMQ for async task processing"
      - "Execution Engine: Separate executor service processes agent workflows"
      - "Authentication: JWT-based with Supabase integration"
      - "Security: Cache protection middleware prevents sensitive data caching"
    
    frontend:
      - "Framework: Next.js App Router with React Server Components"
      - "State Management: React hooks + Supabase client for real-time updates"
      - "Workflow Builder: Visual graph editor using @xyflow/react"
      - "UI Components: Radix UI primitives with Tailwind CSS styling"
      - "Feature Flags: LaunchDarkly integration"
    
    database_schema:
      - "User: Authentication and profile data"
      - "AgentGraph: Workflow definitions with version control"
      - "AgentGraphExecution: Execution history and results"
      - "AgentNode: Individual nodes in a workflow"
      - "StoreListing: Marketplace listings for sharing agents"
  
  ai_agents:
    - "Agent Graphs: Workflow definitions stored as JSON, executed by the backend"
    - "Agents are composed of blocks connected in a directed graph"
    - "Each block has defined inputs, outputs, and execution logic"
    - "Agent execution is handled by the scheduler and executor services"
    - "Blocks can be synchronous or asynchronous operations"
    - "Agent state is persisted between block executions"
    - "Block interfaces should connect productively in graph editor"

  block_development:
    - "Blocks inherit from Block base class in /backend/backend/blocks/"
    - "Define Input/Output schemas with Pydantic models and Field descriptions"
    - "Implement run method with proper async support and error handling"
    - "Register in block registry with unique UUID generated by uuid.uuid4()"
    - "Consider input/output type compatibility for seamless graph connections"
    - "Use descriptive field descriptions for automatic UI generation"
    - "Test blocks individually and in combination with other blocks"

  integrations:
    - "OAuth 2.0 flow for external service authentication"
    - "Webhook handling for real-time event processing"
    - "Rate limiting and retry logic for API calls"
    - "Credential management with encryption at rest"
    - "Integration blocks for connecting to external services"

  platform_architecture:
    - "Microservices communicate via HTTP and message queues"
    - "Database operations use Prisma ORM with PostgreSQL"
    - "Frontend communicates with backend via REST APIs and WebSockets"
    - "Real-time updates use WebSocket connections"
    - "File storage uses Google Cloud Storage"
    - "Virus scanning with ClamAV for uploaded files"
    - "Environment configuration uses layered .env files"

  security_implementation:
    cache_protection:
      - "Located in /backend/backend/server/middleware/security.py"
      - "Default behavior: Disables caching for ALL endpoints"
      - "Uses allow list approach - only explicitly permitted paths can be cached"
      - "Cacheable paths: static assets, health checks, public store pages"
      - "To allow caching: add to CACHEABLE_PATHS in middleware"
      - "Applied to both main API server and external API applications"
    
    general:
      - "Input validation with Pydantic models for all API endpoints"
      - "Authentication required for all protected routes"
      - "User ID validation for data access operations"
      - "Secure credential storage with environment variables"
      - "OWASP security guidelines implementation"

# Development workflow integration
workflow:
  git:
    - "Use conventional commit messages (feat:, fix:, etc.)"
    - "Create feature branches from dev branch"
    - "Write descriptive pull request descriptions"
    - "Include tests for new functionality"
    - "Use .github/PULL_REQUEST_TEMPLATE.md for PR descriptions"
  
  conventional_commits:
    types:
      - "feat: Introduces a new feature to the codebase"
      - "fix: Patches a bug in the codebase"
      - "refactor: Code change that neither fixes a bug nor adds a feature"
      - "ci: Changes to CI configuration"
      - "docs: Documentation-only changes"
      - "dx: Improvements to the developer experience"
    
    scopes:
      - "platform: Changes affecting both frontend and backend"
      - "frontend: Frontend-specific changes"
      - "backend: Backend-specific changes"
      - "infra: Infrastructure changes"
      - "blocks: Modifications/additions of individual blocks"
    
    subscopes:
      - "backend/executor: Executor service changes"
      - "backend/db: Database-related changes"
      - "frontend/builder: Workflow builder changes"
      - "infra/prod: Production infrastructure"

  deployment:
    - "Use Docker for containerization"
    - "Environment variables for configuration"
    - "Database migrations for schema changes"
    - "CI/CD pipeline validation before merge"
    - "Run pre-commit hooks for code quality"

# Prompt customization for better assistance
prompts:
  code_generation:
    - "When creating new blocks, include proper input/output schemas with Field descriptions"
    - "For API endpoints, include proper error handling, validation, and authentication"
    - "For React components, include proper TypeScript types and error boundaries"
    - "Always consider error states and loading states in UI components"
    - "Include proper logging for debugging and monitoring"
    - "Use async/await patterns for I/O operations"
    - "Include proper test cases alongside implementation"
    - "Consider block input/output compatibility for graph connections"

  code_review:
    - "Check for proper error handling and edge cases"
    - "Verify type safety and proper TypeScript usage"
    - "Ensure consistent code style and formatting"
    - "Review for security vulnerabilities and best practices"
    - "Validate test coverage for new functionality"
    - "Check for proper authentication and authorization"
    - "Verify database operations use proper transactions"
    - "Ensure cache protection middleware considerations"

  debugging:
    - "Use poetry run pytest with specific test patterns for backend"
    - "Use npm run test for frontend E2E testing"
    - "Check docker compose logs for service issues"
    - "Use poetry run format and lint for code quality"
    - "Review snapshot test changes carefully before committing"
    - "Use proper logging levels for debugging information"

  documentation:
    - "Include comprehensive docstrings for all public APIs"
    - "Document block functionality with clear examples"
    - "Update README files when adding new features"
    - "Include API documentation for new endpoints"
    - "Document integration patterns and workflows"
    - "Keep CLAUDE.md and AGENTS.md updated with architectural changes"

# AI model preferences for different tasks
model_preferences:
  code_completion: "prioritize_accuracy"
  documentation: "prioritize_clarity" 
  refactoring: "prioritize_safety"
  testing: "prioritize_coverage"
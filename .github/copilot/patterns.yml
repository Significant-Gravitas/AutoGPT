# Code Patterns and Templates for AutoGPT Platform
# This file provides common code patterns and templates for Copilot to learn from

# FastAPI Block Pattern
python_block_template: |
  from typing import Any, Dict, List, Optional
  from pydantic import BaseModel, Field
  from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema
  from backend.data.model import SchemaField

  class {{BlockName}}Input(BaseModel):
      """Input schema for {{block_name}} block."""
      # Define input fields here
      example_field: str = Field(description="Description of the field")

  class {{BlockName}}Output(BaseModel):
      """Output schema for {{block_name}} block."""
      # Define output fields here
      result: str = Field(description="Result of the operation")

  class {{BlockName}}Block(Block):
      """
      {{Description of what this block does}}
      
      Inputs:
      - example_field: Description
      
      Outputs:
      - result: Description
      """
      
      class Input({{BlockName}}Input):
          pass
      
      class Output({{BlockName}}Output):
          pass
      
      def __init__(self):
          super().__init__(
              id="{{block_id}}",
              description="{{Description}}",
              categories={BlockCategory.{{CATEGORY}}},
              input_schema=BlockSchema.create_from_model(self.Input),
              output_schema=BlockSchema.create_from_model(self.Output),
          )
      
      def run(self, input_data: Input, **kwargs) -> BlockOutput:
          """Execute the block logic."""
          try:
              # Implement block logic here
              result = self._process_input(input_data.example_field)
              
              return BlockOutput(
                  id=self.id,
                  data=self.Output(result=result),
              )
          except Exception as e:
              raise Exception(f"{{BlockName}} execution failed: {str(e)}")
      
      def _process_input(self, input_value: str) -> str:
          """Private method to process the input."""
          # Implementation details
          return f"Processed: {input_value}"

# FastAPI Endpoint Pattern
fastapi_endpoint_template: |
  from typing import List, Optional
  from fastapi import APIRouter, Depends, HTTPException, status
  from pydantic import BaseModel, Field
  from backend.data.model import {{ModelName}}
  from backend.util.auth import get_current_user
  from backend.util.request import Request
  
  router = APIRouter(prefix="/{{endpoint_prefix}}", tags=["{{tag_name}}"])
  
  class {{RequestName}}Request(BaseModel):
      """Request model for {{operation_name}}."""
      # Define request fields
      field_name: str = Field(description="Description")
  
  class {{ResponseName}}Response(BaseModel):
      """Response model for {{operation_name}}."""
      # Define response fields
      id: str = Field(description="Resource ID")
      status: str = Field(description="Operation status")
  
  @router.post(
      "/{{endpoint_path}}",
      response_model={{ResponseName}}Response,
      status_code=status.HTTP_201_CREATED,
      summary="{{Operation summary}}",
      description="{{Detailed description}}"
  )
  async def {{function_name}}(
      request: {{RequestName}}Request,
      user_id: str = Depends(get_current_user),
  ) -> {{ResponseName}}Response:
      """{{Endpoint description}}."""
      try:
          # Validate input
          if not request.field_name:
              raise HTTPException(
                  status_code=status.HTTP_400_BAD_REQUEST,
                  detail="Field is required"
              )
          
          # Process request
          result = await _process_{{operation_name}}(request, user_id)
          
          return {{ResponseName}}Response(
              id=result.id,
              status="success"
          )
      except ValueError as e:
          raise HTTPException(
              status_code=status.HTTP_400_BAD_REQUEST,
              detail=str(e)
          )
      except Exception as e:
          raise HTTPException(
              status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
              detail="Internal server error"
          )
  
  async def _process_{{operation_name}}(
      request: {{RequestName}}Request, 
      user_id: str
  ) -> {{ModelName}}:
      """Process the {{operation_name}} request."""
      # Implementation details
      pass

# React Component Pattern
react_component_template: |
  'use client';
  
  import React, { useState, useEffect, useCallback } from 'react';
  import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
  import { {{ComponentName}}Props } from './types';
  import { {{apiMethod}} } from '@/lib/api/{{apiModule}}';
  import { Button } from '@/components/ui/button';
  import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
  import { Alert, AlertDescription } from '@/components/ui/alert';
  import { Loader2 } from 'lucide-react';
  
  interface {{ComponentName}}Props {
    /** Description of prop */
    propName: string;
    /** Optional callback */
    onAction?: (data: any) => void;
    /** Additional CSS classes */
    className?: string;
  }
  
  interface {{DataType}} {
    id: string;
    name: string;
    // Add other fields as needed
  }
  
  export const {{ComponentName}}: React.FC<{{ComponentName}}Props> = ({
    propName,
    onAction,
    className = '',
  }) => {
    const [localState, setLocalState] = useState<string>('');
    const [error, setError] = useState<string | null>(null);
    const queryClient = useQueryClient();
    
    // Query for fetching data
    const {
      data: {{dataName}},
      isLoading,
      error: queryError,
      refetch,
    } = useQuery({
      queryKey: ['{{queryKey}}', propName],
      queryFn: () => {{apiMethod}}(propName),
      enabled: !!propName,
      staleTime: 5 * 60 * 1000, // 5 minutes
    });
    
    // Mutation for updates
    const updateMutation = useMutation({
      mutationFn: {{updateApiMethod}},
      onSuccess: (data) => {
        queryClient.invalidateQueries({ queryKey: ['{{queryKey}}'] });
        onAction?.(data);
        setError(null);
      },
      onError: (error: Error) => {
        setError(error.message);
      },
    });
    
    const handleAction = useCallback(async () => {
      if (!localState.trim()) {
        setError('Input is required');
        return;
      }
      
      try {
        await updateMutation.mutateAsync({
          id: propName,
          data: localState,
        });
      } catch (err) {
        // Error is handled by mutation onError
      }
    }, [localState, propName, updateMutation]);
    
    const handleInputChange = useCallback((value: string) => {
      setLocalState(value);
      if (error) setError(null);
    }, [error]);
    
    if (isLoading) {
      return (
        <Card className={className}>
          <CardContent className="flex items-center justify-center p-6">
            <Loader2 className="h-6 w-6 animate-spin" />
            <span className="ml-2">Loading...</span>
          </CardContent>
        </Card>
      );
    }
    
    if (queryError) {
      return (
        <Alert variant="destructive" className={className}>
          <AlertDescription>
            Failed to load data: {queryError.message}
          </AlertDescription>
        </Alert>
      );
    }
    
    return (
      <Card className={className}>
        <CardHeader>
          <CardTitle>{{Component Title}}</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          {/* Component content */}
          <div className="space-y-2">
            <label htmlFor="input" className="text-sm font-medium">
              Input Label
            </label>
            <input
              id="input"
              type="text"
              value={localState}
              onChange={(e) => handleInputChange(e.target.value)}
              placeholder="Enter value..."
              className="w-full p-2 border rounded-md focus:ring-2 focus:ring-blue-500"
            />
          </div>
          
          <Button
            onClick={handleAction}
            disabled={updateMutation.isPending}
            className="w-full"
          >
            {updateMutation.isPending && (
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            )}
            Action Button
          </Button>
          
          {{{dataName}} && (
            <div className="mt-4">
              <h3 className="text-sm font-medium mb-2">Data:</h3>
              <pre className="text-xs bg-gray-100 p-2 rounded">
                {JSON.stringify({{dataName}}, null, 2)}
              </pre>
            </div>
          )}
        </CardContent>
      </Card>
    );
  };
  
  export default {{ComponentName}};

# Common Hooks Pattern
react_hook_template: |
  import { useState, useEffect, useCallback, useMemo } from 'react';
  import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
  
  interface Use{{HookName}}Options {
    /** Configuration options */
    option?: string;
    /** Callback functions */
    onSuccess?: (data: any) => void;
    onError?: (error: Error) => void;
  }
  
  interface Use{{HookName}}Return {
    /** Data state */
    data: any;
    /** Loading states */
    isLoading: boolean;
    isUpdating: boolean;
    /** Error state */
    error: Error | null;
    /** Action methods */
    update: (data: any) => Promise<void>;
    refresh: () => void;
    reset: () => void;
  }
  
  export const use{{HookName}} = ({
    option,
    onSuccess,
    onError,
  }: Use{{HookName}}Options = {}): Use{{HookName}}Return => {
    const [localError, setLocalError] = useState<Error | null>(null);
    const queryClient = useQueryClient();
    
    const queryKey = useMemo(() => ['{{hookKey}}', option], [option]);
    
    const {
      data,
      isLoading,
      error: queryError,
      refetch,
    } = useQuery({
      queryKey,
      queryFn: () => fetchData(option),
      enabled: !!option,
      onError: (error: Error) => {
        setLocalError(error);
        onError?.(error);
      },
    });
    
    const updateMutation = useMutation({
      mutationFn: updateData,
      onSuccess: (data) => {
        queryClient.invalidateQueries({ queryKey });
        setLocalError(null);
        onSuccess?.(data);
      },
      onError: (error: Error) => {
        setLocalError(error);
        onError?.(error);
      },
    });
    
    const update = useCallback(async (updateData: any) => {
      await updateMutation.mutateAsync(updateData);
    }, [updateMutation]);
    
    const refresh = useCallback(() => {
      refetch();
    }, [refetch]);
    
    const reset = useCallback(() => {
      setLocalError(null);
      queryClient.resetQueries({ queryKey });
    }, [queryClient, queryKey]);
    
    const error = localError || queryError || null;
    
    return {
      data,
      isLoading,
      isUpdating: updateMutation.isPending,
      error,
      update,
      refresh,
      reset,
    };
  };
  
  // Helper functions
  async function fetchData(option?: string): Promise<any> {
    // Implementation
  }
  
  async function updateData(data: any): Promise<any> {
    // Implementation
  }

# Test Patterns
pytest_pattern: |
  import pytest
  from unittest.mock import Mock, patch, AsyncMock
  from fastapi.testclient import TestClient
  from backend.blocks.{{module_name}} import {{BlockClass}}
  
  class Test{{BlockClass}}:
      """Test suite for {{BlockClass}}."""
      
      @pytest.fixture
      def block_instance(self):
          """Create a block instance for testing."""
          return {{BlockClass}}()
      
      @pytest.fixture
      def valid_input(self):
          """Create valid input data for testing."""
          return {{BlockClass}}.Input(
              field_name="test_value"
          )
      
      def test_block_initialization(self, block_instance):
          """Test that block initializes correctly."""
          assert block_instance.id == "{{block_id}}"
          assert block_instance.description
          assert block_instance.input_schema
          assert block_instance.output_schema
      
      async def test_successful_execution(self, block_instance, valid_input):
          """Test successful block execution."""
          result = block_instance.run(valid_input)
          
          assert result.id == block_instance.id
          assert isinstance(result.data, {{BlockClass}}.Output)
          assert result.data.result
      
      async def test_invalid_input_handling(self, block_instance):
          """Test handling of invalid input."""
          invalid_input = {{BlockClass}}.Input(field_name="")
          
          with pytest.raises(Exception) as exc_info:
              block_instance.run(invalid_input)
          
          assert "validation error" in str(exc_info.value).lower()
      
      @patch('backend.blocks.{{module_name}}.external_api_call')
      async def test_external_api_failure(self, mock_api, block_instance, valid_input):
          """Test handling of external API failures."""
          mock_api.side_effect = Exception("API Error")
          
          with pytest.raises(Exception) as exc_info:
              block_instance.run(valid_input)
          
          assert "API Error" in str(exc_info.value)
      
      @pytest.mark.parametrize("input_value,expected", [
          ("test1", "processed_test1"),
          ("test2", "processed_test2"),
          ("", "processed_"),
      ])
      async def test_processing_logic(self, block_instance, input_value, expected):
          """Test various input processing scenarios."""
          result = block_instance._process_input(input_value)
          assert result == expected

playwright_pattern: |
  import { test, expect, Page } from '@playwright/test';
  
  test.describe('{{ComponentName}} Component', () => {
    let page: Page;
    
    test.beforeEach(async ({ page: p }) => {
      page = p;
      await page.goto('/{{component_route}}');
      await page.waitForLoadState('networkidle');
    });
    
    test('should render component correctly', async () => {
      await expect(page.locator('[data-testid="{{component-test-id}}"]')).toBeVisible();
      await expect(page.locator('h1')).toContainText('{{expected_title}}');
    });
    
    test('should handle user interactions', async () => {
      const inputField = page.locator('[data-testid="input-field"]');
      const submitButton = page.locator('[data-testid="submit-button"]');
      
      await inputField.fill('test input');
      await submitButton.click();
      
      await expect(page.locator('[data-testid="success-message"]')).toBeVisible();
    });
    
    test('should display error states', async () => {
      const submitButton = page.locator('[data-testid="submit-button"]');
      
      // Submit without required input
      await submitButton.click();
      
      await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
      await expect(page.locator('[data-testid="error-message"]')).toContainText('required');
    });
    
    test('should handle loading states', async () => {
      // Mock slow API response
      await page.route('**/api/**', async route => {
        await new Promise(resolve => setTimeout(resolve, 1000));
        await route.continue();
      });
      
      const submitButton = page.locator('[data-testid="submit-button"]');
      await submitButton.click();
      
      await expect(page.locator('[data-testid="loading-spinner"]')).toBeVisible();
    });
  });